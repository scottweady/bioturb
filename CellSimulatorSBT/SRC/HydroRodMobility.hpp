#ifndef HYDRORODMOBILITY_HPP_
#define HYDRORODMOBILITY_HPP_

#include "HydroRodOperator.hpp"
#include "Trilinos/Preconditioner.hpp"
#include "Trilinos/TpetraUtil.hpp"
#include "Util/IOHelper.hpp"

#include "Teuchos_YamlParameterListHelpers.hpp"

#include <string>

// mobility matrix mapping [force,torque] to [vel,omega], 6 dof per rod
// Note: this is linear only when withSwim and withForceTorqueExternal are both false
template <class Container>
class HydroRodMobility : public TOP {
  private:
    const Container *const containerPtr;    ///< read-only
    const int nRodLocal;                    ///< local number of rods
    std::shared_ptr<stkfmm::STKFMM> fmmPtr; ///< pointer to fmm, either 3d or above wall
    const Config &cellConfig;               ///< hydro user input
    const SylinderConfig &runConfig;        ///< general user input

    //
    Teuchos::RCP<const TCOMM> commRcp;
    Teuchos::RCP<TMAP> mobMapRcp; ///< mobility map, 6 dof per rod

    // linear problem Ax = b
    Teuchos::RCP<HydroRodOperator<Container>> AOpRcp;
    Teuchos::RCP<TV> xRcp;
    Teuchos::RCP<TV> bRcp;

    Teuchos::RCP<Belos::SolverManager<TOP::scalar_type, TMV, TOP>> solverRcp;
    Teuchos::RCP<Belos::LinearProblem<::TOP::scalar_type, TMV, TOP>> problemRcp;
    Teuchos::RCP<Teuchos::ParameterList> solverParamsRcp;

    void setSolverParameters();

  public:
    HydroRodMobility(const Container *const containerPtr_, const int nRodLocal_,
                     std::shared_ptr<stkfmm::STKFMM> &fmmPtr_, const Config &cellConfig_,
                     const SylinderConfig &runConfig_);

    ~HydroRodMobility() = default;

    Teuchos::RCP<const TMAP> getDomainMap() const { return mobMapRcp; }

    Teuchos::RCP<const TMAP> getRangeMap() const { return mobMapRcp; }

    bool hasTransposeApply() const { return false; }

    // Compute Y := alpha Op X + beta Y.
    void apply(const TMV &X, TMV &Y, Teuchos::ETransp mode = Teuchos::NO_TRANS,
               scalar_type alpha = Teuchos::ScalarTraits<scalar_type>::one(),
               scalar_type beta = Teuchos::ScalarTraits<scalar_type>::zero()) const;


    void writeFlowGridVTI(const std::string &prefix, const double &flowGrid, const bool &wallz0, const double& viscosity, const int &fileID) {
        AOpRcp->writeFlowGridVTI(prefix, flowGrid, wallz0, viscosity, fileID);
    }

    // motion generated by swim and imposed force in hydrotable
    void calcMotion(TV &VelOmegaRcp);

    void setInitialGuess(Teuchos::RCP<TV> &feGuessRcp);

    Teuchos::RCP<HydroRodOperator<Container>> getHydroOperator() const { return AOpRcp; };

    Teuchos::RCP<TV> getfeRcp() const { return xRcp; };

    Teuchos::RCP<TV> getfsRcp() const { return AOpRcp->getfsRcp(); };

    // self test
    void testOperator();
};

template <class Container>
HydroRodMobility<Container>::HydroRodMobility(const Container *const containerPtr_, const int nRodLocal_,
                                              std::shared_ptr<stkfmm::STKFMM> &fmmPtr_, const Config &cellConfig_,
                                              const SylinderConfig &runConfig_)
    : containerPtr(containerPtr_), nRodLocal(nRodLocal_), fmmPtr(fmmPtr_), cellConfig(cellConfig_),
      runConfig(runConfig_) {
    commRcp = getMPIWORLDTCOMM();
    mobMapRcp = getTMAPFromLocalSize(6 * nRodLocal, commRcp);
    AOpRcp = Teuchos::rcp(new HydroRodOperator<Container>(containerPtr, nRodLocal, fmmPtr, cellConfig, runConfig));
    auto xMapRcp = AOpRcp->getDomainMap();
    auto bMapRcp = AOpRcp->getRangeMap();

    xRcp = Teuchos::rcp(new TV(xMapRcp, true));
    bRcp = Teuchos::rcp(new TV(bMapRcp, true));

    // setup the problem
    problemRcp = Teuchos::rcp(new Belos::LinearProblem<TOP::scalar_type, TMV, TOP>(AOpRcp, xRcp, bRcp));

    Belos::SolverFactory<TOP::scalar_type, TMV, TOP> factory;

    // choose solver in constructor
    setSolverParameters();
    solverRcp = factory.create(solverParamsRcp->name(), solverParamsRcp);
    solverRcp->setProblem(problemRcp);
    if (commRcp->getRank() == 0) {
        std::cout << "Iterative Solver: " << solverParamsRcp->name() << std::endl;
    }
}

template <class Container>
void HydroRodMobility<Container>::setSolverParameters() {
    std::string fileName = "mobilitySolver.yaml";
    if (IOHelper::fileExist(fileName))
        solverParamsRcp = Teuchos::getParametersFromYamlFile(fileName);
    else {
        // use default parameters
        solverParamsRcp = Teuchos::parameterList();
        solverParamsRcp->setName("GMRES");
        solverParamsRcp->set("Num Blocks", 30);
        solverParamsRcp->set("Maximum Restarts", 20);
        solverParamsRcp->set("Maximum Iterations", 1000);
        solverParamsRcp->set("Convergence Tolerance", 1e-8);
        solverParamsRcp->set("Timer Label", "HydroRodMobility");
        solverParamsRcp->set("Verbosity", Belos::Errors + Belos::Warnings + Belos::TimingDetails + Belos::FinalSummary);
        solverParamsRcp->set("Output Frequency", -1); // 1 for every iteration
        solverParamsRcp->set("Show Maximum Residual Norm Only", false);
        solverParamsRcp->set("Implicit Residual Scaling", "Norm of RHS");
        solverParamsRcp->set("Explicit Residual Scaling", "Norm of RHS");
    }
}

template <class Container>
void HydroRodMobility<Container>::testOperator() {

    HydroOption option;
    option.withSwim = false;
    option.withForceTorqueExternal = false;

    // calc vel for some x
    Teuchos::RCP<TV> vwVecRcp = Teuchos::rcp(new TV(mobMapRcp, true));
    xRcp->putScalar(0.0);
    AOpRcp->calcVelOmega(*xRcp, *vwVecRcp, option);
    dumpTV(vwVecRcp, "VelOmegaZero");

    option.withSwim = true;
    AOpRcp->calcVelOmega(*xRcp, *vwVecRcp, option);
    dumpTV(vwVecRcp, "VelOmegaZeroWithSwim");

    option.withSwim = false;
    option.withForceTorqueExternal = true;
    AOpRcp->calcVelOmega(*xRcp, *vwVecRcp, option);
    dumpTV(vwVecRcp, "VelOmegaZeroWithExt");

    // test motion driven by swim and external force/torque
    calcMotion(*vwVecRcp);
    dumpTV(bRcp, "sol_bVec");
    dumpTV(xRcp, "sol_x");
    dumpTV(vwVecRcp, "sol_VelOmega");
}

// motion generated by swim and imposed force in hydrotable
template <class Container>
void HydroRodMobility<Container>::calcMotion(TV &VelOmega) {
    // solve Ax=b
    HydroOption option;
    option.withSwim = true;
    option.withForceTorqueExternal = true;
    TV FTinputVec(mobMapRcp, true); // zero forcing except imposed force in hydrotable

    // set right side
    AOpRcp->calcb(FTinputVec, *bRcp, option);

    // use current data in sylinder for initial guess
    auto fhRcp = AOpRcp->getfhRcp();
    auto fsRcp = AOpRcp->getfsRcp();
    xRcp->update(1.0, *fhRcp, 0.0);
    xRcp->update(-1.0, *fsRcp, 1.0);
    // xRcp->putScalar(0);

    bool set = problemRcp->setProblem(xRcp, bRcp);
    TEUCHOS_TEST_FOR_EXCEPTION(!set, std::runtime_error, "*** Belos::LinearProblem failed to set up correctly! ***");
    // solverRcp->reset(Belos::Problem);

    Belos::ReturnType result = solverRcp->solve();
    int numIters = solverRcp->getNumIters();
    if (commRcp->getRank() == 0) {
        std::cout << "RECORD: Num of Iterations in Mobility Matrix: " << numIters << std::endl;
    }
    option.withForceTorqueExternal = false; // avoid double counting
    AOpRcp->calcVelOmega(*xRcp, VelOmega, option);
}

template <class Container>
void HydroRodMobility<Container>::apply(const TMV &X, TMV &Y, Teuchos::ETransp mode, scalar_type alpha,
                                        scalar_type beta) const {
    // X: ForceTorque
    // Y: VelOmega
    // compute Y=alpha*Ax+beta*Y;
    assert(X.getMap()->isSameAs(*(Y.getMap())));
    assert(X.getMap()->isSameAs(*mobMapRcp));
    assert(X.getNumVectors() == Y.getNumVectors());

    Teuchos::RCP<TV> YColOld = Teuchos::rcp(new TV(Y.getMap(), true));
    HydroOption option;
    option.withSwim = false;
    option.withForceTorqueExternal = false;

    const int nCol = X.getNumVectors();
    for (int c = 0; c < nCol; c++) {
        const auto &XCol = X.getVector(c);
        auto YCol = Y.getVectorNonConst(c);
        YColOld->update(beta, *YCol, 0.0); // Yold = beta*Ycol

        // compute YCol=A*XCol
        AOpRcp->calcb(*XCol, *bRcp, option);
        bool set = problemRcp->setProblem(); // iterative solve
        TEUCHOS_TEST_FOR_EXCEPTION(!set, std::runtime_error,
                                   "*** Belos::LinearProblem failed to set up correctly! ***");
        solverRcp->reset(Belos::Problem);
        solverRcp->setProblem(problemRcp);

        Belos::ReturnType result = solverRcp->solve();
        int numIters = solverRcp->getNumIters();
        if (commRcp->getRank() == 0) {
            std::cout << "RECORD: Num of Iterations in Mobility Matrix: " << numIters << std::endl;
        }
        AOpRcp->calcVelOmega(*xRcp, *YCol, option);

        YCol->update(1.0, *YColOld, alpha); // Ycol = alpha*AXcol+beta*Ycol
    }
}

template <class Container>
void HydroRodMobility<Container>::setInitialGuess(Teuchos::RCP<TV> &feGuessRcp) {
    if (feGuessRcp->getMap()->isSameAs(*(xRcp->getMap()))) {
        xRcp = feGuessRcp;
    } else {
        printf("initial guess of fe is invalid\n");
        exit(1);
    }
}
#endif